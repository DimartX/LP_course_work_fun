# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Артемьев Д.И.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта я получу навыки работы с генеалогическими деревьями в формате GEDCOM, парсинга различных файлов на одном из языков программирования. Затем научусь обрабатывать графы звязей между родственниками на Прологе: определять степень родства между двумя людьми, реализовывать естесственно-языковой интерфейс в системе логического программирования. 

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска .... 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Так как на сервисе MyHeritage.com для создания и получения родословного дерева необходимо пройти регистрацию, я решил пойти обходными путями. Сначала нашёл аналог этого сервиса для моего дистрибутива Linux - Grumps. Так как создавать родословные деревья в нём оказалось малоприятным занятием, я нашёл готовое родословное дерево семьи Смит. Однако, там не хватало связей для деемонстрации работы предиката из 3 задания. Поэтому я немного доработал его, добавив придуманных людей. 

Также мне было интересно, как будут работать мои программы с большим генеалогическим деревом. Поэтому я взял предложенное преподавателем древо европейской знати. Сначала встала проблема с кодировкой: в той, что была, русские буквы отображались как странные символы. Методом, предложенным в одной статье на Хабре, я смог определить, что это кодировка windows-1251, и конвертировать её в кодировку utf-8. Таким образом, у меня появилось второе родословное дерево.

## Конвертация родословного дерева

Для парсинга из формата GEDCOM в предикаты Пролога я решил использовать язык Haskell, так как со школы увлекался функциональным программированием на Lisp, и хотел попробовать ещё один язык этой парадигмы. Кроме того, на тот момент я слышал о том, что Хаскель хорошо приспособлен для всякого рода парсинга (за счёт модуля Parsec).

Однако я не успел разобраться в сложных концепциях Хаскеля, таких как монады. Поэтому решил написать парсер своими руками, обладая знаниями по синтаксису и опытом программирования на Lisp.

В итоге моя программа работает следующим образом:
1) Входной поток преобразуется в список слов, затем над ним происходят все операции. 
2) В списке находятся определённые паттерны формата GEDCOM, по типу `0 @I01@ INDI` и начинается добавление личностей в список кортежей (индекс, имя, пол). 
3) Полученный после первого прохода список личностей преобразуется в структуру данных Map, в которой поиск элемента осуществляется не за линейное время, как в списке, а за O(logn)
4) Второй раз прохожу по входному списку и нахожу семейные связи между людьми, нахожу в списке индексы отца/детей, матери/детей и по ним восстанавливаю личность человека из построенной в предыдущем шаге структуры. Полученную связь добавляю в выходной список.
Опишите, какой язык/языки вы решили использовать для решения этой задачи и почему. Опишите принцип действия программы и приведите ключевые фрагменты 
программы, позволяющие понять основные моменты решения.

В итоге у меня получается список прологовских предикатов, который затем нужно отсортировать, но это я делаю при помощи стандартной утилиты шелла - sort.

В итоге на небольшом файле Smith.ged парсер отрабатывает моментально, однако на большом (даже с вырезанной, не относящейся к построению предикатов информацией) файле royal.ged он работает около 20 минут. Процессор Intel(R) Pentium(R) CPU N4200 @ 1.10GHz.

## Предикат поиска родственника

 3. Реализовать предикат проверки/поиска следующих родственников в соответствии с номером варианта ((N-1) mod 7)+1: 
     1. Шурин

Мой предикат состоит из двух: сначала находится жена человека (без многожёнства). Затем ищется брат этой жены, который является сыном общего родителя человека жена. 
```prolog
shurin(Husb, Bro) :- wife(Husb, Wife), brother(Wife, Bro).

wife(X, T) :- father(X, L), mother(T, L), !.

brother(X, Z) :- (father(Y, X), father(Y, Z); mother(T, X), mother(T, Z)), male(Z), X \= Z.
```

Пример работы на файле Smith.pl:
```prolog
?- wife('Martin Smith', L).
%@ L = 'Kerstina Hansdotter'.

?- shurin('Edwin Michael Smith', T).
%@ T = 'Bill Adams' ;
%@ T = 'Greg Adams' ;
%@ T = 'Bill Adams' ;
%@ T = 'Greg Adams' ;
%@ false.

?- shurin(X, Y).
%@ X = 'Edwin Michael Smith',
%@ Y = 'Bill Adams' ;
%@ X = 'Edwin Michael Smith',
%@ Y = 'Greg Adams' ;
%@ X = 'Edwin Michael Smith',
%@ Y = 'Bill Adams' ;
%@ X = 'Edwin Michael Smith',
%@ Y = 'Greg Adams' ;
%@ false.
```

Пример работы на файле royal.pl (здесь допускается многожёнство, из-за чего количество повторений имён больше, чем в предыдущем примере):
```prolog
?- shurin('Алексей Петрович Кропоткин', T).
%@ T = 'Алексей Алексеевич Оболенский' ;
%@ T = 'Михаил Алексеевич Оболенский' ;
%@ T = 'Михаил Алексеевич Оболенский' ;
%@ T = 'Алексей Алексеевич Оболенский' ;
%@ T = 'Михаил Алексеевич Оболенский' ;
%@ T = 'Михаил Алексеевич Оболенский' ;
%@ T = 'Алексей Алексеевич Оболенский' ;
%@ T = 'Михаил Алексеевич Оболенский' ;
%@ T = 'Михаил Алексеевич Оболенский'.

?- shurin(X, Y).
%@ X = Y, Y = 'Аарон Болгарский' ;
%@ X = 'Аарон Болгарский',
%@ Y = 'Алузиан Болгарский' ;
%@ X = 'Аарон Болгарский',
%@ Y = 'Радомир Болгарский' ;
%@ X = 'Аарон Болгарский',
%@ Y = 'Траян Болгарский' ;
%@ X = 'Аарон Болгарский',
%@ Y = 'Фрушин Болгарский' .
```

Как видно из результатов работы, одни и те же люди выводятся несколько раз. Это происходит из-за того, как работает предикат brother. Он срабатывает на обоих родителях.
 
## Определение степени родства

Я реализовал определение степени родства с помощью двух алгоритмов: поиска в глубину и поиска в ширину. При этом, используя поиск ширину, полученный результат (цепочка людей) необходимо преобразовать в родственные связи, так как если хранить родственные связи одновременно со списком людей, получается просадка по памяти. 

Предикат what_relation/3 определяет степень родства близких родвстенников (мать, отец, сын, дочь, муж, жена).

Предикаты для поиска в глубину:
```prolog
prolong_d([X|T], [Y,X|T], S) :-
    what_relation(X, Y, S),
    not(member(Y, [X|T])).

relative_d(A,X,Y) :-
    dpth([X],Y,_,A).

dpth([X|T], X, [X|T], []).
dpth(P, F, L, A) :-
    prolong_d(P, P1, S),
    dpth(P1, F, L, NA),
    append(NA,[S], A).
```

Предикаты для поиска в глубину:
```prolog
chain_to_relations([], []).
chain_to_relations([_], []).
chain_to_relations([C1,C2|T], [R|N]) :-
    what_relation(C2, C1, R),
    chain_to_relations([C2|T], N).

relative_b(A, X, Y) :-
    bdth([[X]], Y, L),
    chain_to_relations(L, A).

prolong_b([X|T], [Y,X|T]) :-
    what_relation(Y, X, _),
    not(member(Y, [X|T])).

bdth([[X|T]|_], X, [X|T]).
bdth([P|QI], X, R) :-
    findall(Z, prolong_b(P, Z), T),
    append(QI, T, QO),  
    bdth(QO, X, R), !.
bdth([_|T], Y, L) :-
    bdth(T, Y, L).
```

Результаты работы на файле Smith.ged:
```prolog
?- relative_d(N, 'Carl Emil Smith', 'Martin Smith').
%@ N = [brother, brother, brother, brother, husband, mother, sister, sister, brother|...] .

?- relative_b(N, 'Carl Emil Smith', 'Martin Smith').
%@ N = [brother, father] .
```

## Естественно-языковый интерфейс

## Выводы

Во время выполнения лабораторной работы я освоил системы построения родословных деревьев в системе Linux, научился писать парсеры на языке функционального программирования Хаскель. Затем я научился выводить информацию на основе реляционного представления рёбер графа родственных связей на языке логического программирования Пролог. Далее я разобрался, как находить пути в графе родственных отношений и выводить цепочку родственных связей для двух заданных людей при помощи алгоритмов поиска пути в Прологе. К сожалению, я пока не успел написать реализацию естесственно-языкового интерфейса.

В целом, эта курсовая работа мне кажется самой интересной из тех, которые были на настоящий момент. Хаскель показался мне крайне интересным языком, который я планирую изучить в ближайшее время. Пролог же оказался на удивление удобным в написании и отладке программ для своего класса задач.
